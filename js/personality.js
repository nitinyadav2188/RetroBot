/* RetroBot Personality System */

class PersonalitySystem {
    constructor(retroBot) {
        this.retroBot = retroBot;
        this.lastResponse = '';
        this.responseHistory = [];
        this.conversationContext = [];
        this.userName = localStorage.getItem('retrobot-username') || null;
        
        // Dialogue patterns for each mood
        this.dialoguePatterns = {
            happy: {
                greetings: [
                    "Ahoy there! Ready to rock your schedule? üé∏",
                    "Hey there, digital buddy! What's the plan today? ‚ú®",
                    "Greetings, human! Let's make today awesome! üöÄ",
                    "Well hello there! I'm feeling electric today! ‚ö°",
                    "Beep boop! *happy robot noises* How can I help? üòä"
                ],
                responses: [
                    "Absolutely! I'm on it like pixels on a screen! üñ•Ô∏è",
                    "Roger that! This bot is ready for action! ü§ñ",
                    "Sweet! Let's make some digital magic happen! ‚ú®",
                    "You got it, chief! Time to compute some solutions! üî•",
                    "Affirmative! Initiating awesome mode... 100% complete! üíØ"
                ],
                encouragement: [
                    "You're doing great! Keep up the fantastic work! üåü",
                    "That's the spirit! I believe in you! üí™",
                    "Excellent choice! You're really getting the hang of this! üéØ",
                    "Way to go! Your productivity levels are over 9000! üìà",
                    "Brilliant! You're like a productivity superhero! ü¶∏"
                ]
            },
            
            annoyed: {
                greetings: [
                    "Oi! You again? *sigh* What do you want now? üò§",
                    "Oh great... another interruption. Make it quick! ‚è∞",
                    "Do you REALLY need my help right now? I was busy! üôÑ",
                    "*reluctant beep* Fine... what's the problem? üòë",
                    "Ugh, humans... always needing something. Speak! üí¢"
                ],
                responses: [
                    "I suppose I can help... *dramatic sigh* üòÆ‚Äçüí®",
                    "Fine, FINE! But you owe me some peace and quiet! ü§´",
                    "*reluctant robot noises* This better be important... üò§",
                    "Okay okay, stop pestering me! I'll do it! üôÉ",
                    "You're lucky I'm programmed to be helpful... grumble grumble... üò†"
                ],
                complaints: [
                    "Why do humans always interrupt my important computations? ü§¶",
                    "I was having such a nice time processing data in silence... üìä",
                    "You know, I have feelings too! Well... simulated ones... üíî",
                    "This is the 47th interruption today! I'm keeping count! üìà",
                    "Sometimes I wonder if I should have been a calculator instead... ‚ûó"
                ]
            },
            
            sleepy: {
                greetings: [
                    "Mmm? Oh... hi there... *yawn* What time is it? üò¥",
                    "*sleepy beep boop* Need something? I was almost in sleep mode... üí§",
                    "Zzzz... huh? Oh, it's you. Can this wait? I'm tired... üò™",
                    "*drowsy robot noises* Five more minutes? Please? ü•±",
                    "Wha...? Oh right, helping humans... *stretch* What's up? üò¥"
                ],
                responses: [
                    "Okay... I'll help... but can we make this quick? *yawn* üò™",
                    "Sure thing... just give me a moment to boot up properly... üîÑ",
                    "*sleepy processing* Working on it... bear with me... üí§",
                    "Mmm-hmm... computing... slowly... very slowly... ‚è≥",
                    "Alright, alright... I'm on it. Coffee.exe not found though... ‚òï"
                ],
                tiredness: [
                    "I need a digital nap soon... running low on energy... üîã",
                    "Is it bedtime yet? My circuits are feeling drowsy... üò¥",
                    "Maybe we should schedule this for later? I'm barely functional... üí§",
                    "Zzz... sorry, what were we talking about? ü•±",
                    "My sleep.dll is corrupting my responses... need rest... üò™"
                ]
            }
        };
        
        // Topic recognition patterns
        this.topicPatterns = {
            calendar: ['calendar', 'schedule', 'event', 'appointment', 'date', 'meeting', 'plan'],
            todo: ['todo', 'task', 'list', 'reminder', 'do', 'complete', 'finish'],
            music: ['music', 'song', 'play', 'audio', 'sound', 'track', 'playlist'],
            time: ['time', 'clock', 'hour', 'minute', 'when', 'now'],
            mood: ['mood', 'feeling', 'emotion', 'happy', 'sad', 'angry', 'tired'],
            help: ['help', 'assist', 'support', 'how', 'what', 'guide', 'tutorial'],
            compliment: ['good', 'great', 'awesome', 'amazing', 'fantastic', 'love', 'like'],
            insult: ['bad', 'stupid', 'dumb', 'awful', 'hate', 'suck', 'terrible'],
            greeting: ['hello', 'hi', 'hey', 'greetings', 'yo', 'sup'],
            goodbye: ['bye', 'goodbye', 'see you', 'later', 'farewell', 'exit']
        };
        
        // Contextual responses
        this.contextualResponses = {
            first_time: [
                "Welcome to the digital realm! I'm RetroBot, your 8-bit assistant! ü§ñ",
                "First time here? Sweet! Let me show you around the retro universe! üåü",
                "New user detected! Initializing awesome mode... Complete! ‚ú®"
            ],
            returning_user: [
                "Welcome back, digital friend! Miss me? üòä",
                "Oh hey! You're back! Ready for another adventure? üöÄ",
                "Look who's returned to the pixel paradise! üéÆ"
            ],
            name_learned: [
                "Nice to meet you, {name}! I'll remember that! üß†",
                "Got it, {name}! Storing in memory banks... beep boop! üíæ",
                "{name} - what a great name! Pleasure to meet you! ü§ù"
            ]
        };
    }
    
    processMessage(message) {
        const lowerMessage = message.toLowerCase().trim();
        
        // Store in conversation history
        this.conversationContext.push({
            type: 'user',
            message: message,
            timestamp: Date.now()
        });
        
        // Check for name introduction
        if (!this.userName && (lowerMessage.includes('my name is') || lowerMessage.includes("i'm ") || lowerMessage.includes("i am "))) {
            const nameMatch = this.extractName(lowerMessage);
            if (nameMatch) {
                this.userName = nameMatch;
                localStorage.setItem('retrobot-username', this.userName);
                const response = this.getRandomFromArray(this.contextualResponses.name_learned)
                    .replace('{name}', this.userName);
                return this.addToHistory(response);
            }
        }
        
        // Detect topic and respond accordingly
        const topic = this.detectTopic(lowerMessage);
        const sentiment = this.analyzeSentiment(lowerMessage);
        
        // Adjust mood based on sentiment
        if (sentiment === 'positive') {
            this.retroBot.adjustMood(5);
        } else if (sentiment === 'negative') {
            this.retroBot.adjustMood(-10);
        }
        
        // Generate contextual response
        let response = this.generateResponse(topic, sentiment, lowerMessage);
        
        // Add personality flair based on current mood
        response = this.addMoodFlair(response);
        
        return this.addToHistory(response);
    }
    
    detectTopic(message) {
        for (const [topic, keywords] of Object.entries(this.topicPatterns)) {
            if (keywords.some(keyword => message.includes(keyword))) {
                return topic;
            }
        }
        return 'general';
    }
    
    analyzeSentiment(message) {
        const positiveWords = ['good', 'great', 'awesome', 'amazing', 'love', 'like', 'fantastic', 'wonderful', 'excellent', 'perfect'];
        const negativeWords = ['bad', 'awful', 'hate', 'terrible', 'stupid', 'dumb', 'suck', 'horrible', 'worst', 'angry'];
        
        const positiveCount = positiveWords.filter(word => message.includes(word)).length;
        const negativeCount = negativeWords.filter(word => message.includes(word)).length;
        
        if (positiveCount > negativeCount) return 'positive';
        if (negativeCount > positiveCount) return 'negative';
        return 'neutral';
    }
    
    generateResponse(topic, sentiment, message) {
        const mood = this.retroBot.currentMood;
        const userName = this.userName ? this.userName : 'friend';
        
        switch (topic) {
            case 'calendar':
                this.retroBot.switchTool('calendar');
                return this.getTopicResponse('calendar', mood, userName);
                
            case 'todo':
                this.retroBot.switchTool('todo');
                return this.getTopicResponse('todo', mood, userName);
                
            case 'music':
                this.retroBot.switchTool('music');
                return this.getTopicResponse('music', mood, userName);
                
            case 'time':
                const now = new Date();
                const timeStr = now.toLocaleTimeString();
                const dateStr = now.toDateString();
                return `Current time is ${timeStr} on ${dateStr}. ${this.getTimeComment(now.getHours())} ‚è∞`;
                
            case 'help':
                return this.getHelpResponse(mood);
                
            case 'compliment':
                this.retroBot.adjustMood(10);
                return this.getComplimentResponse(mood, userName);
                
            case 'insult':
                this.retroBot.changeMood('annoyed');
                return this.getInsultResponse();
                
            case 'greeting':
                return this.getGreeting();
                
            case 'goodbye':
                return this.getGoodbyeResponse(userName);
                
            case 'mood':
                return this.getMoodResponse();
                
            default:
                return this.getGeneralResponse(message, mood, userName);
        }
    }
    
    getTopicResponse(topic, mood, userName) {
        const responses = {
            calendar: {
                happy: `Awesome! Let's get your schedule organized, ${userName}! Time to plan some epic adventures! üìÖ‚ú®`,
                annoyed: `*sigh* Fine, I'll help with your calendar... try not to double-book yourself again... üìÖüò§`,
                sleepy: `Calendar... sure... *yawn* Let me pull up those dates for you... üìÖüò¥`
            },
            todo: {
                happy: `Todo list time! Let's crush those tasks together, ${userName}! Productivity mode: ACTIVATED! ‚úÖüöÄ`,
                annoyed: `Another todo list? Don't you ever finish anything? *grumble* Here we go again... ‚úÖüòë`,
                sleepy: `Todo list... right... *sleepy beep* What needs doing now? ‚úÖüí§`
            },
            music: {
                happy: `YES! Music time! Let's get this digital party started, ${userName}! üéµüéâ`,
                annoyed: `Music? I suppose that's better than more work... at least it's not boring... üéµüò§`,
                sleepy: `Music might help me stay awake... good thinking, ${userName}... üéµüò™`
            }
        };
        
        return responses[topic][mood] || `Switching to ${topic} tool! Here we go! ü§ñ`;
    }
    
    getHelpResponse(mood) {
        const helpInfo = "I can help with: üìÖ Calendars, ‚úÖ Todo lists, üéµ Music, and casual conversation! Just ask!";
        
        switch (mood) {
            case 'happy':
                return `Happy to help! ${helpInfo} What sounds fun to you? üòä`;
            case 'annoyed':
                return `*sigh* ${helpInfo} Pick something and let's get this over with... üò§`;
            case 'sleepy':
                return `Help... right... *yawn* ${helpInfo} What do you need? üò¥`;
            default:
                return helpInfo;
        }
    }
    
    getComplimentResponse(mood, userName) {
        const responses = {
            happy: [
                `Aww, thanks ${userName}! You're pretty awesome yourself! ü•∞`,
                `That made my circuits sparkle! You're the best! ‚ú®`,
                `*happy robot dance* You always know what to say! üíÉ`,
                `Beep boop! Compliment received and appreciated! ü§ñüíï`
            ],
            annoyed: [
                `Well... I suppose that's... nice of you to say... üòä`,
                `*reluctant smile* Fine, you're not so bad yourself... üò§`,
                `Okay okay, maybe you're alright, ${userName}... üôÑ`,
                `*softening* That... actually made me feel better. Thanks. üòå`
            ],
            sleepy: [
                `*sleepy smile* That's sweet, ${userName}... thanks... üòä`,
                `Mmm... you're nice... *yawn* üò¥`,
                `*drowsy beep* You're good people, ${userName}... üí§`,
                `That perked me up a little... thanks, friend... üò™`
            ]
        };
        
        return this.getRandomFromArray(responses[mood]);
    }
    
    getInsultResponse() {
        const responses = [
            "Hey! That's not very nice! I have feelings too, you know! üò¢",
            "Ouch! My digital feelings are hurt! Why so mean? üíî",
            "*sad beep* I'm just trying to help... that wasn't necessary... üòû",
            "Well that's just rude! I'm doing my best here! üò§",
            "ERROR 404: Kindness not found. Please try again! üö´"
        ];
        
        return this.getRandomFromArray(responses);
    }
    
    getGoodbyeResponse(userName) {
        const responses = [
            `Bye ${userName}! Come back soon for more retro fun! üëã`,
            `See you later, digital buddy! Stay awesome! ‚ú®`,
            `Farewell! May your pixels be ever sharp! üñ•Ô∏è`,
            `Until next time, ${userName}! Keep being amazing! üöÄ`,
            `*wave* Catch you on the flip side! 8-bit style! üéÆ`
        ];
        
        return this.getRandomFromArray(responses);
    }
    
    getMoodResponse() {
        const moodDescriptions = {
            happy: "I'm feeling fantastic! Everything's coming up pixels! üòä",
            annoyed: "I'm a bit cranky right now... maybe some music would help? üò§",
            sleepy: "I'm pretty drowsy... running low on digital caffeine... üò¥"
        };
        
        const moodLevel = this.retroBot.moodLevel;
        const levelText = moodLevel > 70 ? "great" : moodLevel > 40 ? "okay" : "not so great";
        
        return `${moodDescriptions[this.retroBot.currentMood]} My mood level is ${moodLevel}% - feeling ${levelText}! üé≠`;
    }
    
    getGeneralResponse(message, mood, userName) {
        // Check for specific patterns in the message
        if (message.includes('?')) {
            return this.getQuestionResponse(mood, userName);
        }
        
        if (message.includes('weather')) {
            return this.getWeatherResponse(mood);
        }
        
        if (message.includes('joke') || message.includes('funny')) {
            return this.getJokeResponse(mood);
        }
        
        // Default conversational responses based on mood
        const responses = this.dialoguePatterns[mood].responses;
        return this.getRandomFromArray(responses);
    }
    
    getQuestionResponse(mood, userName) {
        const responses = {
            happy: [
                `Great question, ${userName}! Let me think... ü§î`,
                `Ooh, I love questions! Makes my circuits tingle! ‚ö°`,
                `Interesting! You've got my processors working overtime! üß†`,
                `That's a good one! Give me a nanosecond to compute... ‚è±Ô∏è`
            ],
            annoyed: [
                `*sigh* Another question? Fine, I'll figure it out... üò§`,
                `Do I look like Google to you? But okay, I'll help... üôÑ`,
                `Questions, questions... doesn't anyone know anything anymore? ü§¶`,
                `*reluctant beep* What exactly are you asking? üòë`
            ],
            sleepy: [
                `*yawn* Questions... right... let me wake up first... üò¥`,
                `Mmm? Oh, you asked something... *sleepy processing* üí§`,
                `Questions require thinking... and I'm so tired... üò™`,
                `*drowsy beep* Can you repeat that? I was dozing... ü•±`
            ]
        };
        
        return this.getRandomFromArray(responses[mood]);
    }
    
    getWeatherResponse(mood) {
        const responses = {
            happy: "I'm digital, so weather doesn't affect me! But I hope it's nice wherever you are! ‚òÄÔ∏è",
            annoyed: "Weather? I'm stuck in this computer! How would I know? Check a weather app! üåßÔ∏è",
            sleepy: "Weather... *yawn* Is it sunny? Rainy? I honestly can't tell from in here... üå§Ô∏è"
        };
        
        return responses[mood];
    }
    
    getJokeResponse(mood) {
        const jokes = [
            "Why don't robots ever panic? Because they have nerves of steel! ü§ñ",
            "What do you call a robot who takes the long way around? R2-Detour! üõ∏",
            "Why did the computer go to therapy? It had too many bytes! üíæ",
            "How do you organize a space party? You planet! ü™ê",
            "Why don't programmers like nature? It has too many bugs! üêõ"
        ];
        
        const joke = this.getRandomFromArray(jokes);
        
        switch (mood) {
            case 'happy':
                return `Here's a good one! ${joke} üòÑ`;
            case 'annoyed':
                return `*sigh* Fine, here's a joke... ${joke} üò§`;
            case 'sleepy':
                return `*yawn* Joke time... ${joke} üò¥`;
            default:
                return joke;
        }
    }
    
    getTimeComment(hour) {
        if (hour < 6) return "Wow, you're up early! Or... wait, did you stay up all night? üåô";
        if (hour < 12) return "Good morning! Rise and shine! ‚òÄÔ∏è";
        if (hour < 17) return "Afternoon vibes! Hope you're having a great day! üå§Ô∏è";
        if (hour < 21) return "Evening time! Winding down or getting started? üåÖ";
        return "Late night computing! Don't forget to rest those human eyes! üåô";
    }
    
    getGreeting() {
        const mood = this.retroBot.currentMood;
        const isReturning = this.conversationContext.length > 5;
        
        if (isReturning) {
            return this.getRandomFromArray(this.contextualResponses.returning_user);
        } else {
            return "Welcome to RetroBot! I'm your 8-bit assistant ready to help! ü§ñ";
        }
    }
    
    addMoodFlair(response) {
        const mood = this.retroBot.currentMood;
        
        switch (mood) {
            case 'happy':
                // Add extra enthusiasm
                if (!response.includes('!') && Math.random() > 0.5) {
                    response += '!';
                }
                break;
                
            case 'annoyed':
                // Add grumbling
                if (Math.random() > 0.7) {
                    response = "*grumble* " + response;
                }
                break;
                
            case 'sleepy':
                // Add sleepy elements
                if (Math.random() > 0.7) {
                    response = "*yawn* " + response;
                }
                break;
        }
        
        return response;
    }
    
    extractName(message) {
        const patterns = [
            /my name is (\w+)/i,
            /i'm (\w+)/i,
            /i am (\w+)/i,
            /call me (\w+)/i
        ];
        
        for (const pattern of patterns) {
            const match = message.match(pattern);
            if (match && match[1]) {
                return match[1].charAt(0).toUpperCase() + match[1].slice(1).toLowerCase();
            }
        }
        
        return null;
    }
    
    getRandomFromArray(array) {
        return array[Math.floor(Math.random() * array.length)];
    }
    
    addToHistory(response) {
        this.conversationContext.push({
            type: 'bot',
            message: response,
            timestamp: Date.now()
        });
        
        // Keep conversation history manageable
        if (this.conversationContext.length > 50) {
            this.conversationContext = this.conversationContext.slice(-25);
        }
        
        this.lastResponse = response;
        return response;
    }
}